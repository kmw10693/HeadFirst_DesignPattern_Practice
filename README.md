1. **전략 패턴(Strategy Pattern)** 은 알고리즘군을 정의하고, 캡슐화해서 각각의 알고리즘군을 수정해서 쓸 수 있게 해 줍니다. 전략 패턴을 사용하면 클라이언트로부터 알고리즘을 분리해서 독립적으로 변경할 수 있습니다.
2. **옵저버 패턴(Observer Pattern)** 은 한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체에게 연락이 가고 자동으로 내용이 갱신되는 방식으로 일대다(one-to-many) 의존성을 정의합니다.
3. **데코레이터 패턴(Decorator Pattern)**은 객체에 추가 요소를 동적으로 더 할 수 있습니다. 데코레이터를 사용하면 서브클래스를 만들 때보다 훨씬 유연하게 기능을 확장할 수 있습니다.

---

##[옵저버 패턴]

- 주제는 옵저버들이 Observer 인터페이스를 구현한다는 것을 제외하면 옵저버에 대해 전혀 모른다. (느슨한 결합)
- 옵저버 패턴은 옵저버가 데이터를 가져오는(풀 방식)을 활용하자.
- 출판-구독 패턴과 친척이다.

**[객체지향 원칙]**

- 바뀌는 부분은 캡슐화한다.
- 상속보다는 구성을 활용한다.
- 구현보다는 인터페이스에 맞춰서 프로그래밍한다.
- 상호작용하는 객체 사이에서는 가능하면 느슨한 결합을 사용해야 한다.

---

##[데코레이터 패턴]

- 데코레이터의 슈퍼클래스는 자신이 장식하고 있는 객체의 슈퍼클래스와 같다.
- 한 객체를 여러 개의 데코레이터로 감쌀 수 있다.
- 데코레이터는 자신이 감싸고 있는 객체와 같은 슈퍼클래스를 가지고 있기에 원래 객체가 들어 갈 자리에 데코레이터 객체를 넣어도 상관없다.
- 데코레이터는 자신이 장식하고 있는 객체에게 어떤 행동을 위임하는 일 말고도 추가 작업을 수행할 수 있다.
- 객체는 언제든지 감쌀 수 있으므로, 실행 중에 필요한 데코레이터를 마음대로 적용할 수 있습니다.
- 특정 형식에 의존하는 클라이언트 코드는 데코레이터 패턴을 적용하면 안된다.